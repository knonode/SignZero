#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 2 8
    bytecblock "init" "finalized" "end" "asa" "start" "text" 0x151f7c75
    // smart_contracts/sign_zero/contract.algo.ts:23
    // export class SignZero extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@10
    pushbytess 0x6cffa84b 0x11ee4219 0xa46848f7 0xee0484c0 0x23d8b7ce 0x2696511d // method "initialize(string,uint64,uint64,byte[],string)uint64", method "writeChunk(uint64,byte[])void", method "sign()void", method "extend(uint64)void", method "finalize()void", method "getInfo()(uint64,uint64,uint64,bool,bool)"
    txna ApplicationArgs 0
    match initialize writeChunk sign extend finalize getInfo
    err

main_create_NoOp@10:
    // smart_contracts/sign_zero/contract.algo.ts:23
    // export class SignZero extends Contract {
    pushbytes 0xb8447b36 // method "createApplication()void"
    txna ApplicationArgs 0
    match createApplication
    err


// smart_contracts/sign_zero/contract.algo.ts::SignZero.createApplication[routing]() -> void:
createApplication:
    // smart_contracts/sign_zero/contract.algo.ts:29
    // initialized = GlobalState<boolean>({ key: 'init' })
    bytec_0 // "init"
    // smart_contracts/sign_zero/contract.algo.ts:38
    // this.initialized.value = false
    intc_0 // 0
    app_global_put
    // smart_contracts/sign_zero/contract.algo.ts:27
    // finalized = GlobalState<boolean>({ key: 'finalized' })
    bytec_1 // "finalized"
    // smart_contracts/sign_zero/contract.algo.ts:39
    // this.finalized.value = false
    intc_0 // 0
    app_global_put
    // smart_contracts/sign_zero/contract.algo.ts:37
    // public createApplication(): void {
    intc_1 // 1
    return


// smart_contracts/sign_zero/contract.algo.ts::SignZero.initialize[routing]() -> void:
initialize:
    // smart_contracts/sign_zero/contract.algo.ts:52
    // public initialize(title: string, textSize: uint64, duration: uint64, opinionType: bytes, url: string): uint64 {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 5
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/sign_zero/contract.algo.ts:54
    // assert(!this.initialized.value, 'Already initialized')
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:29
    // initialized = GlobalState<boolean>({ key: 'init' })
    bytec_0 // "init"
    // smart_contracts/sign_zero/contract.algo.ts:54
    // assert(!this.initialized.value, 'Already initialized')
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Already initialized
    // smart_contracts/sign_zero/contract.algo.ts:57
    // assert(Global.groupSize >= Uint64(2), 'Expected payment + app call')
    global GroupSize
    intc_2 // 2
    >=
    assert // Expected payment + app call
    // smart_contracts/sign_zero/contract.algo.ts:58
    // const payment = gtxn.PaymentTxn(Uint64(0))
    intc_0 // 0
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:60
    // payment.receiver.bytes === Global.currentApplicationAddress.bytes,
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/sign_zero/contract.algo.ts:59-62
    // assert(
    //   payment.receiver.bytes === Global.currentApplicationAddress.bytes,
    //   'Payment must go to app'
    // )
    assert // Payment must go to app
    // smart_contracts/sign_zero/contract.algo.ts:58
    // const payment = gtxn.PaymentTxn(Uint64(0))
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:63
    // assert(payment.amount >= Uint64(MIN_FUNDING), 'Minimum 20 ALGO required')
    gtxns Amount
    pushint 20000000 // 20000000
    >=
    assert // Minimum 20 ALGO required
    // smart_contracts/sign_zero/contract.algo.ts:66
    // assert(duration >= Uint64(MIN_DURATION), 'Minimum duration 25,000 rounds')
    dig 2
    pushint 25000 // 25000
    >=
    assert // Minimum duration 25,000 rounds
    // smart_contracts/sign_zero/contract.algo.ts:69
    // assert(title !== '', 'Title cannot be empty')
    dig 4
    pushbytes ""
    !=
    assert // Title cannot be empty
    // smart_contracts/sign_zero/contract.algo.ts:70
    // assert(Bytes(title).length <= Uint64(32), 'Title exceeds 32 bytes')
    dig 4
    len
    pushint 32 // 32
    <=
    assert // Title exceeds 32 bytes
    // smart_contracts/sign_zero/contract.algo.ts:73
    // assert(textSize > Uint64(0), 'Text size must be > 0')
    dig 3
    assert // Text size must be > 0
    // smart_contracts/sign_zero/contract.algo.ts:74
    // assert(textSize <= Uint64(32768), 'Text exceeds 32KB')
    dig 3
    pushint 32768 // 32768
    <=
    assert // Text exceeds 32KB
    // smart_contracts/sign_zero/contract.algo.ts:77
    // assert(opinionType.length === Uint64(32), 'Opinion type must be 32 bytes')
    dig 1
    len
    pushint 32 // 32
    ==
    assert // Opinion type must be 32 bytes
    // smart_contracts/sign_zero/contract.algo.ts:78
    // assert(opinionType !== op.bzero(32), 'Opinion type cannot be empty')
    pushint 32 // 32
    bzero
    dig 2
    !=
    assert // Opinion type cannot be empty
    // smart_contracts/sign_zero/contract.algo.ts:81
    // assert(Bytes(url).length <= Uint64(96), 'URL exceeds 96 bytes')
    dup
    len
    pushint 96 // 96
    <=
    assert // URL exceeds 96 bytes
    // smart_contracts/sign_zero/contract.algo.ts:84
    // const startRound: uint64 = Global.round
    global Round
    // smart_contracts/sign_zero/contract.algo.ts:85
    // const endRound: uint64 = startRound + duration
    dup
    uncover 4
    +
    // smart_contracts/sign_zero/contract.algo.ts:25
    // startRound = GlobalState<uint64>({ key: 'start' })
    bytec 4 // "start"
    // smart_contracts/sign_zero/contract.algo.ts:86
    // this.startRound.value = startRound
    uncover 2
    app_global_put
    // smart_contracts/sign_zero/contract.algo.ts:26
    // endRound = GlobalState<uint64>({ key: 'end' })
    bytec_2 // "end"
    // smart_contracts/sign_zero/contract.algo.ts:87
    // this.endRound.value = endRound
    swap
    app_global_put
    // smart_contracts/sign_zero/contract.algo.ts:32
    // opinionText = Box<string>({ key: 'text' })
    bytec 5 // "text"
    // smart_contracts/sign_zero/contract.algo.ts:90
    // this.opinionText.create({ size: textSize })
    uncover 3
    box_create
    pop
    // smart_contracts/sign_zero/contract.algo.ts:93-107
    // const asaResult = itxn
    //   .assetConfig({
    //     total: Uint64(0),
    //     decimals: Uint64(0),
    //     assetName: title,
    //     unitName: 'ZERO',
    //     metadataHash: opinionType.toFixed({ length: 32, strategy: 'assert-length' }),
    //     url: url,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Txn.sender, // Opinion author stored here
    //     freeze: Account(),
    //     clawback: Account(),
    //     fee: Uint64(0),
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/sign_zero/contract.algo.ts:101
    // manager: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/sign_zero/contract.algo.ts:102
    // reserve: Txn.sender, // Opinion author stored here
    txn Sender
    // smart_contracts/sign_zero/contract.algo.ts:103
    // freeze: Account(),
    global ZeroAddress
    // smart_contracts/sign_zero/contract.algo.ts:104
    // clawback: Account(),
    dup
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    itxn_field ConfigAssetURL
    itxn_field ConfigAssetMetadataHash
    // smart_contracts/sign_zero/contract.algo.ts:98
    // unitName: 'ZERO',
    pushbytes "ZERO"
    itxn_field ConfigAssetUnitName
    itxn_field ConfigAssetName
    // smart_contracts/sign_zero/contract.algo.ts:96
    // decimals: Uint64(0),
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // smart_contracts/sign_zero/contract.algo.ts:95
    // total: Uint64(0),
    intc_0 // 0
    itxn_field ConfigAssetTotal
    // smart_contracts/sign_zero/contract.algo.ts:93-106
    // const asaResult = itxn
    //   .assetConfig({
    //     total: Uint64(0),
    //     decimals: Uint64(0),
    //     assetName: title,
    //     unitName: 'ZERO',
    //     metadataHash: opinionType.toFixed({ length: 32, strategy: 'assert-length' }),
    //     url: url,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Txn.sender, // Opinion author stored here
    //     freeze: Account(),
    //     clawback: Account(),
    //     fee: Uint64(0),
    //   })
    pushint 3 // 3
    itxn_field TypeEnum
    // smart_contracts/sign_zero/contract.algo.ts:105
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/sign_zero/contract.algo.ts:93-107
    // const asaResult = itxn
    //   .assetConfig({
    //     total: Uint64(0),
    //     decimals: Uint64(0),
    //     assetName: title,
    //     unitName: 'ZERO',
    //     metadataHash: opinionType.toFixed({ length: 32, strategy: 'assert-length' }),
    //     url: url,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Txn.sender, // Opinion author stored here
    //     freeze: Account(),
    //     clawback: Account(),
    //     fee: Uint64(0),
    //   })
    //   .submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/sign_zero/contract.algo.ts:28
    // asaId = GlobalState<uint64>({ key: 'asa' })
    bytec_3 // "asa"
    // smart_contracts/sign_zero/contract.algo.ts:110
    // this.asaId.value = asaId
    dig 1
    app_global_put
    // smart_contracts/sign_zero/contract.algo.ts:29
    // initialized = GlobalState<boolean>({ key: 'init' })
    bytec_0 // "init"
    // smart_contracts/sign_zero/contract.algo.ts:113
    // this.initialized.value = true
    intc_1 // 1
    app_global_put
    // smart_contracts/sign_zero/contract.algo.ts:52
    // public initialize(title: string, textSize: uint64, duration: uint64, opinionType: bytes, url: string): uint64 {
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/sign_zero/contract.algo.ts::SignZero.writeChunk[routing]() -> void:
writeChunk:
    // smart_contracts/sign_zero/contract.algo.ts:124
    // public writeChunk(offset: uint64, data: bytes): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/sign_zero/contract.algo.ts:125
    // assert(this.initialized.value, 'Not initialized')
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:29
    // initialized = GlobalState<boolean>({ key: 'init' })
    bytec_0 // "init"
    // smart_contracts/sign_zero/contract.algo.ts:125
    // assert(this.initialized.value, 'Not initialized')
    app_global_get_ex
    assert // check GlobalState exists
    assert // Not initialized
    // smart_contracts/sign_zero/contract.algo.ts:126
    // assert(!this.finalized.value, 'Opinion already finalized')
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:27
    // finalized = GlobalState<boolean>({ key: 'finalized' })
    bytec_1 // "finalized"
    // smart_contracts/sign_zero/contract.algo.ts:126
    // assert(!this.finalized.value, 'Opinion already finalized')
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Opinion already finalized
    // smart_contracts/sign_zero/contract.algo.ts:129
    // assert(Txn.sender === Asset(this.asaId.value).reserve, 'Only author can write')
    txn Sender
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:28
    // asaId = GlobalState<uint64>({ key: 'asa' })
    bytec_3 // "asa"
    // smart_contracts/sign_zero/contract.algo.ts:129
    // assert(Txn.sender === Asset(this.asaId.value).reserve, 'Only author can write')
    app_global_get_ex
    assert // check GlobalState exists
    asset_params_get AssetReserve
    assert // asset exists
    ==
    assert // Only author can write
    // smart_contracts/sign_zero/contract.algo.ts:32
    // opinionText = Box<string>({ key: 'text' })
    bytec 5 // "text"
    // smart_contracts/sign_zero/contract.algo.ts:132
    // this.opinionText.replace(offset, data)
    cover 2
    box_replace
    // smart_contracts/sign_zero/contract.algo.ts:124
    // public writeChunk(offset: uint64, data: bytes): void {
    intc_1 // 1
    return


// smart_contracts/sign_zero/contract.algo.ts::SignZero.sign[routing]() -> void:
sign:
    // smart_contracts/sign_zero/contract.algo.ts:141
    // assert(this.initialized.value, 'Not initialized')
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:29
    // initialized = GlobalState<boolean>({ key: 'init' })
    bytec_0 // "init"
    // smart_contracts/sign_zero/contract.algo.ts:141
    // assert(this.initialized.value, 'Not initialized')
    app_global_get_ex
    assert // check GlobalState exists
    assert // Not initialized
    // smart_contracts/sign_zero/contract.algo.ts:144
    // assert(Global.round <= this.endRound.value, 'Opinion has ended')
    global Round
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:26
    // endRound = GlobalState<uint64>({ key: 'end' })
    bytec_2 // "end"
    // smart_contracts/sign_zero/contract.algo.ts:144
    // assert(Global.round <= this.endRound.value, 'Opinion has ended')
    app_global_get_ex
    assert // check GlobalState exists
    <=
    assert // Opinion has ended
    // smart_contracts/sign_zero/contract.algo.ts:145
    // assert(!this.finalized.value, 'Opinion already finalized')
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:27
    // finalized = GlobalState<boolean>({ key: 'finalized' })
    bytec_1 // "finalized"
    // smart_contracts/sign_zero/contract.algo.ts:145
    // assert(!this.finalized.value, 'Opinion already finalized')
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Opinion already finalized
    // smart_contracts/sign_zero/contract.algo.ts:148
    // assert(Global.groupSize === Uint64(2), 'Expected app call + ASA opt-in')
    global GroupSize
    intc_2 // 2
    ==
    assert // Expected app call + ASA opt-in
    // smart_contracts/sign_zero/contract.algo.ts:151
    // const optIn = gtxn.AssetTransferTxn(Uint64(1))
    intc_1 // 1
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    intc_1 // 1
    // smart_contracts/sign_zero/contract.algo.ts:152
    // assert(optIn.xferAsset.id === this.asaId.value, 'Must opt into opinion ASA')
    gtxns XferAsset
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:28
    // asaId = GlobalState<uint64>({ key: 'asa' })
    bytec_3 // "asa"
    // smart_contracts/sign_zero/contract.algo.ts:152
    // assert(optIn.xferAsset.id === this.asaId.value, 'Must opt into opinion ASA')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Must opt into opinion ASA
    // smart_contracts/sign_zero/contract.algo.ts:151
    // const optIn = gtxn.AssetTransferTxn(Uint64(1))
    intc_1 // 1
    // smart_contracts/sign_zero/contract.algo.ts:153
    // assert(optIn.assetAmount === Uint64(0), 'Must be opt-in (amount 0)')
    gtxns AssetAmount
    !
    assert // Must be opt-in (amount 0)
    // smart_contracts/sign_zero/contract.algo.ts:151
    // const optIn = gtxn.AssetTransferTxn(Uint64(1))
    intc_1 // 1
    // smart_contracts/sign_zero/contract.algo.ts:154
    // assert(optIn.sender.bytes === Txn.sender.bytes, 'Opt-in sender must match caller')
    gtxns Sender
    txn Sender
    ==
    assert // Opt-in sender must match caller
    // smart_contracts/sign_zero/contract.algo.ts:151
    // const optIn = gtxn.AssetTransferTxn(Uint64(1))
    intc_1 // 1
    // smart_contracts/sign_zero/contract.algo.ts:155
    // assert(optIn.assetReceiver.bytes === Txn.sender.bytes, 'Opt-in receiver must match caller')
    gtxns AssetReceiver
    txn Sender
    ==
    assert // Opt-in receiver must match caller
    // smart_contracts/sign_zero/contract.algo.ts:139
    // public sign(): void {
    intc_1 // 1
    return


// smart_contracts/sign_zero/contract.algo.ts::SignZero.extend[routing]() -> void:
extend:
    // smart_contracts/sign_zero/contract.algo.ts:162
    // public extend(newEndRound: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/sign_zero/contract.algo.ts:164
    // assert(this.initialized.value, 'Not initialized')
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:29
    // initialized = GlobalState<boolean>({ key: 'init' })
    bytec_0 // "init"
    // smart_contracts/sign_zero/contract.algo.ts:164
    // assert(this.initialized.value, 'Not initialized')
    app_global_get_ex
    assert // check GlobalState exists
    assert // Not initialized
    // smart_contracts/sign_zero/contract.algo.ts:167
    // const asa = Asset(this.asaId.value)
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:28
    // asaId = GlobalState<uint64>({ key: 'asa' })
    bytec_3 // "asa"
    // smart_contracts/sign_zero/contract.algo.ts:167
    // const asa = Asset(this.asaId.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/sign_zero/contract.algo.ts:168
    // assert(Txn.sender.bytes === asa.reserve.bytes, 'Only author can extend')
    txn Sender
    swap
    asset_params_get AssetReserve
    assert // asset exists
    ==
    assert // Only author can extend
    // smart_contracts/sign_zero/contract.algo.ts:171
    // assert(!this.finalized.value, 'Opinion already finalized')
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:27
    // finalized = GlobalState<boolean>({ key: 'finalized' })
    bytec_1 // "finalized"
    // smart_contracts/sign_zero/contract.algo.ts:171
    // assert(!this.finalized.value, 'Opinion already finalized')
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Opinion already finalized
    // smart_contracts/sign_zero/contract.algo.ts:174
    // assert(newEndRound > this.endRound.value, 'New end must be greater')
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:26
    // endRound = GlobalState<uint64>({ key: 'end' })
    bytec_2 // "end"
    // smart_contracts/sign_zero/contract.algo.ts:174
    // assert(newEndRound > this.endRound.value, 'New end must be greater')
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    <
    assert // New end must be greater
    // smart_contracts/sign_zero/contract.algo.ts:26
    // endRound = GlobalState<uint64>({ key: 'end' })
    bytec_2 // "end"
    // smart_contracts/sign_zero/contract.algo.ts:177
    // this.endRound.value = newEndRound
    swap
    app_global_put
    // smart_contracts/sign_zero/contract.algo.ts:162
    // public extend(newEndRound: uint64): void {
    intc_1 // 1
    return


// smart_contracts/sign_zero/contract.algo.ts::SignZero.finalize[routing]() -> void:
finalize:
    // smart_contracts/sign_zero/contract.algo.ts:186
    // assert(this.initialized.value, 'Not initialized')
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:29
    // initialized = GlobalState<boolean>({ key: 'init' })
    bytec_0 // "init"
    // smart_contracts/sign_zero/contract.algo.ts:186
    // assert(this.initialized.value, 'Not initialized')
    app_global_get_ex
    assert // check GlobalState exists
    assert // Not initialized
    // smart_contracts/sign_zero/contract.algo.ts:189
    // assert(Global.round > this.endRound.value, 'Opinion still active')
    global Round
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:26
    // endRound = GlobalState<uint64>({ key: 'end' })
    bytec_2 // "end"
    // smart_contracts/sign_zero/contract.algo.ts:189
    // assert(Global.round > this.endRound.value, 'Opinion still active')
    app_global_get_ex
    assert // check GlobalState exists
    >
    assert // Opinion still active
    // smart_contracts/sign_zero/contract.algo.ts:192
    // assert(!this.finalized.value, 'Opinion already finalized')
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:27
    // finalized = GlobalState<boolean>({ key: 'finalized' })
    bytec_1 // "finalized"
    // smart_contracts/sign_zero/contract.algo.ts:192
    // assert(!this.finalized.value, 'Opinion already finalized')
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Opinion already finalized
    // smart_contracts/sign_zero/contract.algo.ts:195
    // const asa = Asset(this.asaId.value)
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:28
    // asaId = GlobalState<uint64>({ key: 'asa' })
    bytec_3 // "asa"
    // smart_contracts/sign_zero/contract.algo.ts:195
    // const asa = Asset(this.asaId.value)
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/sign_zero/contract.algo.ts:196-205
    // itxn
    //   .assetConfig({
    //     configAsset: asa,
    //     manager: Account(),
    //     reserve: asa.reserve, // Keep author address
    //     freeze: Account(),
    //     clawback: Account(),
    //     fee: Uint64(0),
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/sign_zero/contract.algo.ts:199
    // manager: Account(),
    global ZeroAddress
    // smart_contracts/sign_zero/contract.algo.ts:200
    // reserve: asa.reserve, // Keep author address
    dig 1
    asset_params_get AssetReserve
    assert // asset exists
    // smart_contracts/sign_zero/contract.algo.ts:201
    // freeze: Account(),
    global ZeroAddress
    // smart_contracts/sign_zero/contract.algo.ts:202
    // clawback: Account(),
    dup
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    itxn_field ConfigAsset
    // smart_contracts/sign_zero/contract.algo.ts:196-204
    // itxn
    //   .assetConfig({
    //     configAsset: asa,
    //     manager: Account(),
    //     reserve: asa.reserve, // Keep author address
    //     freeze: Account(),
    //     clawback: Account(),
    //     fee: Uint64(0),
    //   })
    pushint 3 // 3
    itxn_field TypeEnum
    // smart_contracts/sign_zero/contract.algo.ts:203
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/sign_zero/contract.algo.ts:196-205
    // itxn
    //   .assetConfig({
    //     configAsset: asa,
    //     manager: Account(),
    //     reserve: asa.reserve, // Keep author address
    //     freeze: Account(),
    //     clawback: Account(),
    //     fee: Uint64(0),
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/sign_zero/contract.algo.ts:27
    // finalized = GlobalState<boolean>({ key: 'finalized' })
    bytec_1 // "finalized"
    // smart_contracts/sign_zero/contract.algo.ts:208
    // this.finalized.value = true
    intc_1 // 1
    app_global_put
    // smart_contracts/sign_zero/contract.algo.ts:212
    // Global.currentApplicationAddress.balance - Global.currentApplicationAddress.minBalance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    -
    dup
    // smart_contracts/sign_zero/contract.algo.ts:215
    // if (reward > Uint64(0)) {
    bz finalize_after_if_else@5
    // smart_contracts/sign_zero/contract.algo.ts:216-222
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: reward,
    //     fee: Uint64(0),
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/sign_zero/contract.algo.ts:218
    // receiver: Txn.sender,
    txn Sender
    dig 1
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/sign_zero/contract.algo.ts:216-221
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: reward,
    //     fee: Uint64(0),
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/sign_zero/contract.algo.ts:220
    // fee: Uint64(0),
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/sign_zero/contract.algo.ts:216-222
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: reward,
    //     fee: Uint64(0),
    //   })
    //   .submit()
    itxn_submit

finalize_after_if_else@5:
    // smart_contracts/sign_zero/contract.algo.ts:184
    // public finalize(): void {
    intc_1 // 1
    return


// smart_contracts/sign_zero/contract.algo.ts::SignZero.getInfo[routing]() -> void:
getInfo:
    // smart_contracts/sign_zero/contract.algo.ts:232
    // this.startRound.value,
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:25
    // startRound = GlobalState<uint64>({ key: 'start' })
    bytec 4 // "start"
    // smart_contracts/sign_zero/contract.algo.ts:232
    // this.startRound.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/sign_zero/contract.algo.ts:233
    // this.endRound.value,
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:26
    // endRound = GlobalState<uint64>({ key: 'end' })
    bytec_2 // "end"
    // smart_contracts/sign_zero/contract.algo.ts:233
    // this.endRound.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/sign_zero/contract.algo.ts:234
    // this.asaId.value,
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:28
    // asaId = GlobalState<uint64>({ key: 'asa' })
    bytec_3 // "asa"
    // smart_contracts/sign_zero/contract.algo.ts:234
    // this.asaId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/sign_zero/contract.algo.ts:235
    // this.finalized.value,
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:27
    // finalized = GlobalState<boolean>({ key: 'finalized' })
    bytec_1 // "finalized"
    // smart_contracts/sign_zero/contract.algo.ts:235
    // this.finalized.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/sign_zero/contract.algo.ts:236
    // this.initialized.value,
    intc_0 // 0
    // smart_contracts/sign_zero/contract.algo.ts:29
    // initialized = GlobalState<boolean>({ key: 'init' })
    bytec_0 // "init"
    // smart_contracts/sign_zero/contract.algo.ts:236
    // this.initialized.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/sign_zero/contract.algo.ts:231-237
    // return [
    //   this.startRound.value,
    //   this.endRound.value,
    //   this.asaId.value,
    //   this.finalized.value,
    //   this.initialized.value,
    // ]
    uncover 4
    itob
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    pushbytes 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    // smart_contracts/sign_zero/contract.algo.ts:229
    // @abimethod({ readonly: true })
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
